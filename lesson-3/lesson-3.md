# Урок 3. Системы управления базами данных MongoDB и SQLite в Python

Нереляционные базы данных
## SQL NoSQL

sql
atomicity - атомароность
consistency - согласованность
isolation - изолированность
durability - устройчивость
У монго такого нет, зато они проще и работают быстрее
NoSQL
* Ключ-значение (redis, berkeley DB)
* Документированные (MongoDB, CouchDB) Дают больше возможностей, поскольку предоставляют больше возможностей. одна единица данных - документ.
* Графовые Giraph, Neo4j - о семантических связях связях
* BigTable (Hbase, cassandra) давно не слышно не видно.

## Что такое MongoDB и почему она

* поле `_id` - первичный ключ
Монго не накладывает ограничения на документ.
То есть в монге нет связей. Но обычно есть правила о которых всетаки договариваются, поскольку может ломаться обработка.
Единственное правило которое требует монга от разработчика, это поле `_id`.
Если поле с двумя одинаковыми `_id`, то приложение свалится, и потом иди ищи какой из 1000500 документов не обработался из-за `_id`. !!!

Чтобы такую же структуру поддерживать в SQL, вам на каждую связь потребуется создавать таблицу, поэтому добавить такую структуру сложнее. Поэтому на страте разработке Монга проще, особенно, когда заказчик не знает чего хочет.

Плюсы:
* скорость разработки
* Нет необходимости в поддержке схемы и в коде  в БД
* Легкая масштабируемость
* Гибкасть при смене задачи
* Удобство работы с денормализованными данными

SQL быстрее ищет данные, но нужно заниматься схемой.

## Установка
mongodb try services.
windows нюансы

активная служба - когда вы включаете компьютер. в состоянии покоя не отжирает много ресурсов, то отжирает 10 мб. Удобно использовать, не надо ничего запускать.
компас - приложения для просмотра базы.
Установите и компас и сервер.
`$ mongod.exe --dbpath D:/bases`
Чтобы закрыть сервис, нужно просто закрыть окно.

> show dbs
> use mvideo - переключиться в базу
> use new_db - создать новую и перейти в нее
> зачем создавать базу, под это регистрировать базу, поэтому use просто запоминает имя, и show dbs не покажет новую базу, до тех пор пока не добавим данные в нее.
> Если колонка не доступна в записи, то при работе с ней, записи без этой колонки будут игнорироваться и мы про это никогда не узнаем.
> 
pip install pymongo
```python
from pymongo import MongoClient
client = MongoClient('127.0.0.1', 27017)
db = client['users2511']
authors = db.authors
books = db.books
doc = {}
authors.insert_one(doc)
authors.insert_many([{}, {}])
# все документы которые после ошибочной записи
# не будут добавлены. Используйте `insert_one` вместе `insert_many`.


for doc in authors.find({}):
    pprint(doc)
```

```python
xx.find({}) # - возвращает итерируемый объект.
xx.find_one({}) # возвращается объект. Если ничего не найдено, то верноет None, значит можно `if result:`
# множество неупорядоченных элементов, поэтому find_one не гарантирует порядок один и тот же всегда, просто один.
```

После миллиона записей начинает проигрывать sql.
Критерии поиска задаются с помощью словаря.
```python
find({'field': 'value'})
find({'author': 'Peter2', 'age': 36}) # AND
find({'$or': [{'author': 'Peter2'}, {'age': 36}]}) # author == 'Peter2' OR age == 36
```

### Условия

```python
find({'age': {'$gte': 35}}) # age > 35
```

### Вхождение в какое-нибудь поле

find({'author': {'$regex': 'J.'})

## Update

update_one({'author': 'Peter1'}, {'$set': {'author': 'Petr'}}) # любое поле можно добавить, даже и несуществующее
чтобы убрать поле нужно выполнить команду '$unset' с пустым значением поля.
в случае с сетом старые поля не удаляются, гораздо проще заменить использовать `replace_one`

replace_one({'author': 'Peter1'}, new_data)
update_many - можем в одном запросе изменить несколько записей.

## Удаление

delete_one({})
delete_many({}) - коллекция останется, но пустой.

## Домашняя работа 2:12:21

Во второй решаем сразу два обязательных задания.
Не должно копироваться с дублями.
Способы уникальности:
* контроль на стороне базы данных
  * на конкретное поле `authors.create_index(['name', pymongo.TEXT], unique=True, name='search_index')` код не верен, смотри документацию.
  * генерировать специфичным образом _id
* контроль на стороне клиента.

## Домашняя работа (прошлая)

